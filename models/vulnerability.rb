##
# Copyright (c) 2016, salesforce.com, inc.
# All rights reserved.
# Licensed under the BSD 3-Clause license. 
# For full license text, see LICENSE.txt file in the repo root  or https://opensource.org/licenses/BSD-3-Clause
##

##
# A single vulnerability found as part of a {Test}
class Vulnerability
	include DataMapper::Resource

	property :id,				Serial 						#@return [Integer] Primary Key
	property :test_id,			Integer 					#@return [Integer] ID of {Test} the Vulnerability belongs to
	property :vulntype, 		Integer 					#@return [Integer] ID of {VulnType} this Vulnerability uses. 0 = Custom vulnerability
	property :custom,			String, :length => 100		#@return [String] Name of Vulnerability class if custom vulnerability
	
	property :created_at, 		DateTime					#@return [DateTime] Date/Time Vulnerability created (DM Handled)
	property :updated_at, 		DateTime					#@return [DateTime] Date/Time Vulnerability last updated (DM Handled)
	
	property :verified,			Boolean, :default => true 	#@return [Boolean] True if this vuln is verified
	property :falsepos,			Boolean, :default => false 	#@return [Boolean] True if this vuln is marked as a false positive
	property :priorityOverride,	Integer 					#@return [Integer] Priority of this vulnerability (overrides VulnType priority)
	property :cweOverride,		Integer						#@return [Integer] CWE mapping of this vulnerability (overrides VulnType cwe_mapping)
	property :starred,			Boolean, :default => false  #@return [Boolean] True if this Vulnerability is starred (flagged as worth saving/teaching from)
	property :vulnSource, 		Integer, :default => 0 		#@return [Integer] ID of the {VulnSource} for this Vulnerability. Default 0 - manual testing

	belongs_to :test 										#@return [Test] Test this Vulnerability belongs to
	has n, :sections

	##
	# Get the {VulnType} object that this Vulnerability uses
	## @return [VulnType]
	def vtobj
		return VulnType.get(self.vulntype)
	end

	##
	# Get Vulnerability type name (e.g. Stored XSS). 
	# Returns VulnType label if not custom, otherwise custom Vulnerability name. If the VulnType has no label, return the VulnType name
	# @return [String] Vulnerability type name
	def type_str
		return custom if vulntype == 0

		vt = VulnType.get(vulntype)
		return (vt.label.nil? || vt.label.strip.empty?) ? vt.name : vt.label
	end

	##
	# Get HTML for icon representing status (verified, unverified, false positive) of this Vulnerability
	# @return [String] HTML for status icon
	def status_icon
		return '<i class="fa fa-check" rel="tooltip" title="Vuln Verified" style="color:#009933;"></i>' if  (verified && !falsepos)
		return '<i class="fa fa-question" rel="tooltip" title="UNVERIFIED Vuln" style="color:#B40404;"></i>' if !verified
		return '<i class="fa fa-bug" rel="tooltip" title="False Positive" style="color:#8A6D3B;"></i>' if falsepos
	end

	##
	# Get HTML for formatted status text (verified, unverified, false positive) of this Vulnerability
	# @return [String] HTML for status text
	def status_text
		return '<span style="color:#009933;">Verified Vuln</span>' if (verified && !falsepos)
		return '<span style="color:#B40404;">Unverified Vuln</span>' if !verified
		return '<span style="color:#8A6D3B;">False Positive</span>' if falsepos
	end

	##
	# Get HTML of Vulnerability type description to use in generated reports
	# @return [String] HTML description of Vulnerability type
	def type_html
		return nil if(vulntype == 0) 

		vt = VulnType.get(vulntype)
		return vt.html
	end

	##
	# Get locations this vulnerability was found in. Locations are any URL or FILE sections on the Vulnerability
	# @return [Array<String>] Vulnerability locations
	def descriptor
		dses = []
		self.sections.each do |s|
			dses << Rack::Utils.escape_html(s.body) if s.type == SECT_TYPE::URL || s.type == SECT_TYPE::FILE
		end

		dses.join ", "
	end

	##
	# Get all sections on this Vulnerability marked as visible for exported reports
	# @return [Array<Section>] Sections attached to this Vulnerability marked visible for export reports (show == true)
	def visible_sections
		return self.sections(:show => true)
	end

	##
	# Get priority of this vulnerability - either {VulnType}'s priority or overridden priority level for this Vulnerability.
	# @return [VULN_PRIORITY]
	def vuln_priority
		vtPri = self.vtobj.priority unless vulntype == 0

		return priorityOverride if(!priorityOverride.nil?)
		return VULN_PRIORITY::NONE if ((vulntype == 0 && priorityOverride.nil?) || vtPri.nil?)
		return vtPri
	end

	##
	# Get cwe_mapping of this vulnerability - either {VulnType}'s or overridden cwe_mapping on this Vulnerability
	# @return [Integer] CWE mapping
	def cwe_mapping
		if(self.vulntype == 0 || !self.cweOverride.nil?)
			return self.cweOverride
		else
			return self.vtobj.cwe_mapping
		end
	end

	##
	# @return [String] Link to CWE definition on Mitre's website if CWE-mapping exists
	def cwe_link
		if(self.cwe_mapping.nil? || self.cwe_mapping <= 0)
			return nil
		else
			return "https://cwe.mitre.org/data/definitions/#{self.cwe_mapping}.html"
		end
	end

	##
	# @return [String] String name of Vulnerability's source
	def source_string
		if(self.vulnSource.nil? || self.vulnSource <= 0)
			return "Manual Testing"
		else
			vs = VulnSource.get(self.vulnSource)
			if(vs.nil?)
				return "UNK"
			else
				return vs.name
			end
		end
	end

	##
	# @return [String] String short name of Vulnerability's source
	def source_short_string
		if(self.vulnSource.nil? || self.vulnSource <= 0)
			return "Manual"
		else
			vs = VulnSource.get(self.vulnSource)
			if(vs.nil?)
				return "UNK"
			else
				return vs.shortname
			end
		end
	end

	##
	# Get vulns on {Test}s that are on apps with any of the given flags and match given parameters.
	# This method passes through to Vulnerability.all with additional parameters to properly filter by flag
	# @param selectedFlags [Array] Array of flag IDs to filter by
	# @param params [Hash] Additional params to pass to Vulnerability.all
	# @return [Array<Vulnerability>] Matching Vulnerability objects
	def self.allWithFlags(selectedFlags, params={})
		if(selectedFlags.include?(-1))
			return all(params)
		else
			return all({Vulnerability.test.application.flags.id => selectedFlags}.merge(params))
		end
	end

	##
	# Count Vulnerability objects that have the given flags and match given parameters.
	# This method passes through to Vulnerability.count with additional parameters to properly filter by flag
	# @param selectedFlags [Array<Integer>] Flags to filter by
	# @param params [Hash] Additional params to pass to Vulnerability.count
	# @return [Array<Vulnerability>] Number of matching Vulnerability objects
	def self.countWithFlags(selectedFlags, params={})
		return allWithFlags(selectedFlags, params.merge({:fields => [:id]})).size
	end
end